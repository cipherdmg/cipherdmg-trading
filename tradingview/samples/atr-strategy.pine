// ||###################################################################################||
// ||                                                                                   ||
// || Moving Average                                                                    ||
// ||                                                                                   ||
// || The strategy goes long when the faster SMA 50 crosses above the SMA 200.          ||
// || Orders are closed when the SMA 50 crosses below SMA 200. The strategy does not    ||
// || short.                                                                            ||
// ||                                                                                   ||
// || This simple strategy does not have any other stop loss or take profit money       ||
// || management logic.                                                                 ||
// ||
// || https://www.tradingview.com/script/e1iapmtK-KL-Relative-Volume-ATR-Strategy/
// ||                                                                                   ||
// ||###################################################################################||

//@version=5
strategy('Relative Volume and ATR Strategy', overlay=true, pyramiding=1)
ENUM_LONG = 'Long'


len_volat = input(14, title='Length of ATR to determine volatility')
ATR_volat = ta.atr(len_volat)
avg_ATR_volat = ta.sma(ATR_volat, len_volat)
std_ATR_volat = ta.stdev(ATR_volat, len_volat)
// }

// Trailing stop loss {
ATR_X2_TSL = ta.atr(input(14, title='Length of ATR for trailing stop loss')) * input(2.0, title='ATR Multiplier for trailing stop loss')
TSL_source = low
var stop_loss_price = float(0)
TSL_line_color = color.green
TSL_transp = 100
if strategy.position_size == 0 or year < 2020
    TSL_line_color := color.black
    stop_loss_price := TSL_source - ATR_X2_TSL
    stop_loss_price
else if strategy.position_size > 0
    stop_loss_price := math.max(stop_loss_price, TSL_source - ATR_X2_TSL)
    TSL_transp := 0
    TSL_transp
plot(stop_loss_price, color=color.new(TSL_line_color, TSL_transp))
// }

// Signals for entry {
_avg_vol = ta.sma(volume, input(20, title='SMA(volume) length (for relative comparison)'))
_relative_vol = _avg_vol * input(1.5, title='Multiple of avg vol to consider relative volume as being high')
entry_signal1 = volume > _relative_vol
entry_signal2 = ATR_volat < avg_ATR_volat + std_ATR_volat and ATR_volat > avg_ATR_volat - std_ATR_volat

USE_DRIFT = input(true, title='Use drift to determine uptrend')
len_drift = input(50, title='Length of Drift')
percentage_chng = math.log(close / close[1])
drift = ta.sma(percentage_chng, len_drift) - math.pow(ta.stdev(percentage_chng, len_drift), 2) * 0.5
entry_signal3 = drift > drift[1] or not USE_DRIFT
// }

alert_per_bar(msg) =>
    prefix = '[' + syminfo.root + '] '
    suffix = '(P=' + str.tostring(close) + '; atr=' + str.tostring(ATR_volat) + ')'
    alert(str.tostring(prefix) + str.tostring(msg) + str.tostring(suffix), alert.freq_once_per_bar)

// MAIN:
if year >= 2020
    if strategy.position_size > 0 and strategy.position_size[1] > 0 and stop_loss_price / stop_loss_price[1] - 1 > 0.005
        alert_per_bar('TSL raised to ' + str.tostring(stop_loss_price))

    exit_msg = close <= strategy.position_avg_price ? 'stop loss' : 'take profit'
    // EXIT:
    if strategy.position_size > 0 and TSL_source <= stop_loss_price
        strategy.close(ENUM_LONG, comment=exit_msg)
    // ENTRY:
    else if (strategy.position_size == 0 or strategy.position_size > 0 and close > stop_loss_price) and entry_signal1 and entry_signal2 and entry_signal3
        entry_msg = strategy.position_size > 0 ? 'adding' : 'initial'
        strategy.entry(ENUM_LONG, strategy.long, comment=entry_msg)

// CLEAN UP:
if strategy.position_size == 0
    stop_loss_price := float(0)
    stop_loss_price

